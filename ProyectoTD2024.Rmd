---
title: "Pon un título a tu documento"
author: "Pon aquí tu nombre y apellidos"
date: "`r Sys.Date()`"
output:
  
  pdf_document:
    toc: true
    toc_depth: 3
    number_sections: true
  html_document:
    echo: true
    number_sections: true
    theme: lumen
    toc: true
  html_notebook:
    echo: true
    number_sections: true
    toc: true
  bookdown::html_document2:
    echo: true
    number_sections: true
    theme: spacelab
    toc: true
  bookdown::pdf_document2:
    toc: true
    toc_depth: 3
    number_sections: true
always_allow_html: true
params:
  lang: ES
lang: "`r switch(params$lang, ES = 'es-ES', EN = 'en-US')`"
subtitle: "Tratamiento de Datos. Grado en Ciencia de Datos- UV"
language:
  label:
    fig: 'Figura '
    tab: 'Tabla '
    eq: 'Ecuación '
    thm: 'Teorema '
    lem: 'Lema '
    def: 'Definición '
    cor: 'Corolario '
    prp: 'Proposición '
    exm: 'Ejemplo '
    exr: 'Ejercicio '
    proof: 'Demostración. '
    remark: 'Nota: '
    solution: 'Solución. '
---
```{r setup,include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
rm(list=ls())
```
#Índice:

1. Introducción al trabajo.

  1.1 Carga de librerías y datos necesarios para
    el análisis.
    
  1.2 Características generales de los datos.
  
  1.3 Análisis de missing data en nuestro conjunto
    de interés.
    
2. Exploración / visualización.

  2.1. Análisis univariante.
  
  2.2. Análisis bivariante.
  
3. CONCLUSIÓN.



##1. Introducción al trabajo.

  Este proyecto trata de desarrollar un programa que permita analizar una serie de tickets de compras en un       supermercado. El objetivo es enfrentarse a un problema real detratamiento de datos, realizando un seguimiento   de (evolución de precios, compras más habituales, productosmás consumidos, supermercado habitual, hora de       compra,etc). El proyecto ha sido realizado con control de cambios GIT. Tiene un repositorio compartido entre    las miembros del grupo llamado ProyectoTD2024 en la plataforma GitHub y en el cual se ven los cambios y         desarrollo del trabajo. Se dispone de varios tickets para empezar a trabajar y un júpiter notebook de python    (TicketPDF2TXT.ipynb) que transforma todos los ficheros con extensión pdf presentes en la carpeta data en       ficheros de texto con toda la información.
  
##1.1 Carga de librerías y datos necesarios para el análisis:

  En primer lugar, hemos cargado todas las librerías necesarias en las diferentes fases del proyecto. Haciendo    esto de una forma eficiente, comprobando si el usuario tiene instalados los paquetes necesarios y               descargandolos en caso necesario.
  A continuación, se realiza la carga del conjunto de datos que provienen de los tickets de un supermercado, en   este caso, del Mercadona. Estos tickets se encuentran en dos tipos de formato, algunos están en .pdf y otros    en .txt almacenados en la carpeta ‘data’ incluida en el repositorio del proyecto. Debido a la mezcla de         formatos, para analizar nuestros datos necesitamos tener todos los archivos en formato .txt, para así poder     analizar los correctamente, por lo que usaremos el archivo "TicketPDF2TXT.ipynb" que nos ha proporcionado el    profesor de la asignatura, contenido también en nuestro repertorio, que automáticamente transforma los tickets   en formato .pdf a formato .txt. Para poder leer la  información de forma adecuada y clarificadora creamos       distintos dataframes con la distinta información que nos puede aportar cada uno de los tickets.
  
  Para ello, hemos de crear distintos dataframes, ya que, un mismo ticket no presenta siempre la misma            estructura. Es decir, en un ticket podemos encontrar frutas y verduras (que tienen un formato distinto, el      precio no es por unidad, si no por peso), pescados (que también siguen otro tipo de formato, el precio también   va por peso, y, además, encontraremos un string que indicará la sección ‘Pescados’), productos restantes, una 
  serie de datos sobre cada Mercadona, información sobre el servicio Parking. De esta forma, uniendo los          diferentes dataframes creados(mediante un XXX_join()), obtenemos un dataframe final, con todos los datos de     cada ticket en un formato correcto(df_tickets). Sin embargo, observando todos los tickets recabados, el inicio   es siempre igual, por lo que creamos una variable en la que guardamos las primeras ocho líneas. Luego           almacenamos los productos en distintas listas, almacenando finalmente cuatro listas: una total y tres           separadas en productos, pescado y fruta. Además sabemos que algunos supermercados tienen parking y otros no     por lo que creamos una variable para detectar aquellos tickets que presenten parking y los que no.              Seguidamente, hemos creado una función que detecte donde terminan los productos y donde empieza el final del    ticket, ya que cada ticket tiene un número distinto de productos, y así podemos observar las similitudes entre   el final de los tickets. También utilizamos dos funciones específicas para analizar la fruta y el pescado, ya   que tiene su propio formato. En este momento de la importación, realizamos un data.frame conjunto, teniendo     en cuenta el identificador de cada ticket, y separando con la fruta, el pescado y los productos resultantes.
  
  Finalmente obtenemos un data.frame con absolutamente toda la información contenida en el ticket pero de forma   concisa, estructurada, ordenada y correcta.
  

```{r include=FALSE}

# Este bloque se encarga de instalar los paquetes necesarios.

packages = c("tidyverse","knitr","reshape2", "lubridate")
package.check <- lapply(packages, FUN = function(x) {
  if (!require(x, character.only = TRUE)) {
    install.packages(x, dependencies = TRUE,repos='http://cran.rediris.es')
  }
  library(x, character.only = TRUE)
})

search()

# Asegúrate que el paquete "pacman" está instalado
if (!require("pacman")) install.packages("pacman")
```

##1.2 Características generales de los datos:

  Es posible hacerse una idea rápida de cuáles son los datos que contiene el data.frame, ‘df_tickets’, haciendo   uso de la función glimpse, de la librería dplyr. En resumen, nuestro dataframe cuenta con 16 variables, con     las cuales vamos a poder responder a nuestras preguntas ya que se corresponden con el contenido del ticket      ordenado.

```{r  include=FALSE}

# Cargamos en la variable. 'rutas' los archivos que deseamos leer,
# poseemos de 12 archivos a leer, que se corresponden
# a 12 tickets de compra de un supermercado:
rutas <- list.files("data/",  pattern = "\\.txt$")
```

```{r include=FALSE}
# DATAFRAMES individuales:

# Data frame para almacenar todos los datos de los tickets.
df_todos <- data.frame()  
# Data frame para almacenar los datos de los productos de los tickets.
df_productos_todos <- data.frame() 
# Data frame para almacenar los datos de la fruta de los tickets.
df_fruta_todos <- data.frame()
# Data frame para almacenar los datos del pescado de los tickets.
df_pescado_todos <- data.frame()  

# Recorremos los archivos mediante un bucle 'para',
# para así poder cargar en un data frame todos
# los datos de los tickets:
for (archivo in rutas){
  
  # Utilizamos la función 'readlines()'
  x <- readLines(paste("data", archivo, sep = "/"), encoding = "latin1")
   
  prod <- x[8:length(x)]   # Notamos que las primeras líneas de los tickets son iguales siempre:
  producto <- list()  # Lista para almacenar los productos.
  lista_pescado = list()  # Lista para almacenar los productos de pescado.
  lista_fruta = list()  # Lista para almacenar los productos de fruta.
  final <- list()  # Lista para almacenar la información final de cada ticket.
  enc = FALSE  # Variable para controlar si se ha encontrado la línea 'TOTAL (€)'.
  pescado = FALSE  # Variable para controlar si se está procesando pescado.
  fruta = FALSE  # Variable para controlar si se está procesando fruta.
  parking = FALSE  # Variable para controlar si se ha encontrado la línea 'PARKING'.
  
  # Bucle 'para' con el objetivo de encontrar los elementos deseados:
   for (elemento in prod){
     
     # Vemos que, el final de cada tiquet es diferente,
     # depende de los productos de cada ticket.
     # Destacar a partir de la línea donde se encuentra
     # 'TOTAL (€)' :

     if (grepl("TOTAL", elemento)){
         enc = TRUE
     }
     if (grepl("PARKING", elemento)){
         parking = TRUE
     }
     
     if (!grepl("\\d$", elemento) & (grepl("^1", elemento))) {
         fruta = TRUE # Indicar que se está procesando fruta
         pescado = FALSE
      }
          if (pescado == TRUE & enc == FALSE & fruta == FALSE){
       lista_pescado <- c(lista_pescado, elemento) # Añadir elemento a la lista de productos de pescado.
          }
           if (grepl("PESCADO", elemento) & (!grepl("^1", elemento))){
         pescado = TRUE # Indicar que se está procesando pescado.
         fruta = FALSE # Resetear la variable de procesamiento de fruta.
     }
      # Comprobar si la línea no termina con un número 
      # y no se ha empezado a procesar pescado.
      



    # Procesamiento de la línea dependiendo de las condiciones anteriores.
     if (enc == FALSE & pescado == FALSE & fruta == FALSE & parking == FALSE){
         producto <- c(producto, elemento)  # Añadir elemento a la lista de productos
     }
     if (fruta == TRUE & enc == FALSE & pescado == FALSE & parking == FALSE){
       lista_fruta <- c(lista_fruta, elemento) #Añadir elemento a la lista de productos de fruta.
     }
     if (enc == TRUE){
       final <- c(final, elemento) # Añadir elemento a la lista de información final.
     }

     
   }
   if (parking == TRUE){
       parkingl <- "SI"
     }else{
       parkingl <- "NO"
     }
   partes <- strsplit(x[5], " OP: ")[[1]]
   id <- strsplit(x[6], "FACTURA SIMPLIFICADA: ")[[1]]
   telef <- strsplit(x[4], "TELÉFONO: ")[[1]]
   # Crear el dataframe principal con la información obtenida
   df <- data.frame(Nombre = x[1], Calle = x[2], Municipio = x[3], Telefono = telef[2], Fecha = partes[1],  OP = partes[2], Factura_simpl= id[[2]], Parking = parkingl, Productos = producto[0:length(producto)])
  
  # Convertir el dataframe de formato ancho a formato largo:
  df <- pivot_longer(df, names_to = "Producto", values_to = "Productos", cols = -c("Nombre","Calle", "Municipio", "Telefono", "Fecha", "OP", "Factura_simpl", "Parking")) 

  # Agregar el dataframe actual al dataframe general:
  df_todos <- rbind(df_todos, df)
  total_columnas <- ncol(df)
  posicion <- total_columnas - 1
  df <- df[, -posicion]
  
  # Cantidad:
  df_productos <- select(df, 1, 7, 9) # tenemos en cuenta el identificador ('Factura_simpl').
  df_separado <- df_productos %>%
  mutate(Cantidad = substr(Productos, 1, 1))
  df_separado$Productos <- substr(df$Productos, 2, nchar(df$Productos))
  df_separado$Cantidad <- as.numeric(df_separado$Cantidad)
  
  # Importe:
  df_separado$Importe <- sub("^.*\\s+(\\d+[,.]\\d+)$", "\\1", df_separado$Productos)
  df_separado$Importe <- gsub(",", ".", df_separado$Importe)
  df_separado$Importe <- as.numeric(df_separado$Importe)
  
  # Precio por Unidad:
  df_separado <- df_separado %>% mutate(PUnidad = Importe / Cantidad)

  # Nombre del producto:

# Creamos una nueva columna "Nombre" con la parte de la columna "Productos" correspondiente al nombre del producto
df_separado$Nombre <- substr(df_separado$Productos, 1, nchar(df_separado$Productos) - 4 - 1)

# Si la cantidad es mayor que 1, ajustamos la columna "Nombre" eliminando la parte correspondiente al precio unitario
df_separado$Nombre[df_separado$Cantidad > 1] <- substr(df_separado$Nombre[df_separado$Cantidad > 1], 1, nchar(df_separado$Nombre[df_separado$Cantidad > 1]) - 4 - 1)

# Sobrescribir la columna Productos con sólo el nombre del producto:
  df_separado$Productos <- df_separado$Nombre
  
  
  df_separado$Total_euros <- sub("^.*\\s+(\\d+[,.]\\d+)$", "\\1", final[1])
  df_separado$Total_euros <- gsub(",", ".", df_separado$Total_euros)
  df_separado$Total_euros <- as.numeric(df_separado$Total_euros)
  df_separado$OP <- partes[2]
  df_separado$Parking <- parkingl
  
  # Lo añadimos en el data frame conjunto:
  df_productos_todos <- rbind(df_productos_todos, df_separado)

  
  if (length(lista_fruta) != 0 ){
    df_fruta <- data.frame(Productos = character(), Info = character(), OP = character())
    indice <- length(lista_fruta) -1
    i <- 1  # Inicializar el índice.
  
  # Bucle 'mientras' para creación de df_fruta:
  while (i <= indice) {

    df_fruta <- rbind(df_fruta, data.frame(Productos = lista_fruta[[i]], Info = lista_fruta[[i+1]], OP = partes[[2]]))
    i <- i + 2  
  }
    df_fruta <- df_fruta %>%
    mutate(Cantidad = as.numeric(substr(Productos, 1, 1)))
    df_fruta$Nombre <- substr(df_fruta$Productos, 2, nchar(df_fruta$Productos))
    df_fruta$Importe <- sub("^.*\\s+(\\d+[,.]\\d+)$", "\\1", df_fruta$Info)
    df_fruta$Kgs <- sub("^(\\d+[,.]\\d+).*", "\\1", df_fruta$Info)
    df_fruta$Importe <- gsub(",", ".", df_fruta$Importe)
    df_fruta$Kgs <- gsub(",", ".", df_fruta$Kgs)
    df_fruta$Importe <- as.numeric(df_fruta$Importe)
    df_fruta$Kgs <- as.numeric(df_fruta$Kgs)
    df_fruta$Factura_simpl <- id[[2]]
    df_fruta$Total_euros <- sub("^.*\\s+(\\d+[,.]\\d+)$", "\\1", final[1])
    df_fruta$Total_euros <- gsub(",", ".", df_fruta$Total_euros)
    df_fruta$Total_euros <- as.numeric(df_fruta$Total_euros)
    df_fruta <- df_fruta %>% mutate(Eur_el_Kg = round(Importe / Kgs, 2))
    df_fruta_todos <- rbind(df_fruta_todos, df_fruta)
   
  }
  if (length(lista_pescado) != 0 ){
    df_pescado <- data.frame(Productos = character(), Info = character(), OP = character())
    indice <- length(lista_pescado) -1
    i <- 1  # Inicializar el índice
  
  # Bucle 'mientras' para creación de df_pescado:
  while (i <= indice) {
    df_pescado <- rbind(df_pescado, data.frame(Productos = lista_pescado[[i]], Info = lista_pescado[[i+1]], OP = partes[2]) )
    i <- i + 2  
  }
    df_pescado$Nombre <- substr(df_pescado$Productos, 1, nchar(df_pescado$Productos))
    df_pescado$Importe <- sub("^.*\\s+(\\d+[,.]\\d+)$", "\\1", df_pescado$Info)
    df_pescado$Kgs <- sub("^(\\d+[,.]\\d+).*", "\\1", df_pescado$Info)
    df_pescado$Importe <- gsub(",", ".", df_pescado$Importe)
    df_pescado$Kgs <- gsub(",", ".", df_pescado$Kgs)
    df_pescado$Importe <- as.numeric(df_pescado$Importe)
    df_pescado$Kgs <- as.numeric(df_pescado$Kgs)
    df_pescado$Total_euros <- sub("^.*\\s+(\\d+[,.]\\d+)$", "\\1", final[1])
    df_pescado$Total_euros <- gsub(",", ".", df_pescado$Total_euros)
    df_pescado$Total_euros <- as.numeric(df_pescado$Total_euros)
    df_pescado <- df_pescado %>% mutate(Eur_el_Kg = round(Importe / Kgs, 2))
    df_pescado$Factura_simpl <- id[[2]]
    df_pescado_todos <- rbind(df_pescado_todos, df_pescado)

  }
}
```

```{r  include=FALSE}
# En este momento de la Importación, realizaremos un DATAFRAME conjunto(df_tickets).


# Tenemos en cuenta el identificador de cada ticket, y además destacar
# cada tipo de formado dentro de productos:fruta, pescado y productos restantes.
#F ruta:
x_fruta <- df_fruta_todos$Productos 
# Productos en general(sin fruta ni pescado), ya que tienen un formato != :
x_prod <- df_productos_todos$Productos
# Pescados:
x_pescado <- df_pescado_todos$Productos
# Añadimos al vector de fruas, el vector de productos restantes,
# mediante un append:
Productos <- append(x_fruta, x_prod)

# Dataframe uniendo la fruta y los productos restantes,
# mediante un full_join:
df_total <- full_join(df_fruta_todos, df_productos_todos, by="Productos")

# Arreglamos el dataframe con el fotmato adecuado para las vbles correspondientes:
df_total <- df_total %>% mutate(Nombre_def = ifelse(is.na(Nombre.x), Nombre.y, Nombre.x)) %>% select(!c(Nombre.x, Nombre.y)) %>% mutate(Nombre= Nombre_def) %>%select(!Nombre_def)

df_total <- df_total %>% mutate(Cantidad_def = ifelse(is.na(Cantidad.x), Cantidad.y, Cantidad.x)) %>% select(!c(Cantidad.x, Cantidad.y)) %>% mutate(Cantidad=Cantidad_def) %>% select(!Cantidad_def)

df_total <- df_total %>% mutate(Importe_def = ifelse(is.na(Importe.x), Importe.y, Importe.x)) %>% select(!c(Importe.x, Importe.y))%>% mutate(Importe=Importe_def) %>% select(!Importe_def)

df_total <- df_total %>% mutate(OP_def = ifelse(is.na(OP.x), OP.y, OP.x)) %>% select(!c(OP.x, OP.y))%>% mutate(OP=OP_def) %>% select(!OP_def)

df_total <- df_total %>%
  mutate(Factura_simpl_def = ifelse(is.na(Factura_simpl.y), Factura_simpl.x, Factura_simpl.y)) %>%
  select(-c(Factura_simpl.y, Factura_simpl.x)) %>%
  mutate(Factura_simpl = Factura_simpl_def) %>%
  select(-Factura_simpl_def)

df_total <- df_total %>% mutate(Total_euros_def = ifelse(is.na(Total_euros.x), Total_euros.y, Total_euros.x)) %>% select(!c(Total_euros.x, Total_euros.y)) %>% mutate(Total_euros=Total_euros_def) %>% select(!Total_euros_def)

# Dataframe uniendo el df_total (fruta+productos) y los pescados,
# mediante un full_join:
df_total_def <- full_join(df_total, df_pescado_todos, by="Productos")

# Arreglamos el dataframe con el fotmato adecuado para las variables correspondientes:
df_total_def <- df_total_def %>% mutate(Nombre_def = ifelse(is.na(Nombre.x), Nombre.y, Nombre.x)) %>% select(!c(Nombre.x, Nombre.y)) %>% mutate(Nombre= Nombre_def) %>%select(!Nombre_def)

df_total_def <- df_total_def %>% mutate(Importe_def = ifelse(is.na(Importe.x), Importe.y, Importe.x)) %>% select(!c(Importe.x, Importe.y))%>% mutate(Importe=Importe_def) %>% select(!Importe_def)

df_total_def <- df_total_def %>% mutate(OP_def = ifelse(is.na(OP.x), OP.y, OP.x)) %>% select(!c(OP.x, OP.y))%>% mutate(OP=OP_def) %>% select(!OP_def)

df_total_def <- df_total_def %>% mutate(Kgs_def = ifelse(is.na(Kgs.x),Kgs.y, Kgs.x)) %>% select(!c(Kgs.x, Kgs.y)) %>% mutate(Kgs= Kgs_def) %>%select(!Kgs_def)

df_total_def <- df_total_def %>% mutate(Eur_el_Kg_def = ifelse(is.na(Eur_el_Kg.x), Eur_el_Kg.y, Eur_el_Kg.x)) %>% select(!c(Eur_el_Kg.x, Eur_el_Kg.y)) %>% mutate(Eur_el_Kg=Eur_el_Kg_def) %>% select(!Eur_el_Kg_def)

df_total_def <- df_total_def %>% mutate(Info_def = ifelse(is.na(Info.x), Info.y, Info.x)) %>% select(!c(Info.x, Info.y)) %>% mutate(Info=Info_def) %>% select(!Info_def)



df_total_def <- df_total_def %>%
  mutate(Factura_simpl_def = ifelse(is.na(Factura_simpl.y), Factura_simpl.x, Factura_simpl.y)) %>%
  select(-c(Factura_simpl.y, Factura_simpl.x)) %>%
  mutate(Factura_simpl = Factura_simpl_def) %>%
  select(-Factura_simpl_def)

df_total_def <- df_total_def %>% mutate(Total_euros_def = ifelse(is.na(Total_euros.x), Total_euros.y, Total_euros.x)) %>% select(!c(Total_euros.x, Total_euros.y)) %>% mutate(Total_euros=Total_euros_def) %>% select(!Total_euros_def)

#Hacemos el entorno amigable:
df_calles <- df_todos  %>% select(!c(Producto,Productos,OP)) %>% mutate(nombre_super = Nombre)  %>% select(!Nombre) 

df_calles <- unique(df_calles)

#DATAFRAME OBJETIVO (final), con la información de todos los productos de
#cada ticket, incluidos la fruta y los pescados,
#además de la información de cada supermercado:
df_total_def <- left_join(df_total_def,df_calles,by = "Factura_simpl")
df_tickets <- df_total_def %>% mutate(Parking_def = ifelse(is.na(Parking.x), Parking.y, Parking.x)) %>% select(!c(Parking.x, Parking.y)) %>% mutate(Parking=Parking_def) %>% select(!Parking_def)
df_tickets$Parking <- as.factor(df_tickets$Parking)

```

```{r   include=FALSE}
df_calles <- df_tickets %>% select(!c(Productos,Info,Eur_el_Kg,Kgs,Importe,Nombre,OP, Cantidad, PUnidad))
df_calles <- unique(df_calles)

#Tener en cuenta el formato 'Fecha' correcto.
df_calles <- separate(df_calles, Fecha, into = c("Fecha", "Hora"), sep = " ")
#df_calles$Hora <- hm(df_calles$Hora)


df_fruta_pescados <- full_join(df_fruta_todos, df_pescado_todos, by = "Productos" )

# Arreglamos el dataframe con el formato adecuado para las vbles correspondientes:
df_fruta_pescados <- df_fruta_pescados %>% mutate(Nombre_def = ifelse(is.na(Nombre.x), Nombre.y, Nombre.x)) %>% select(!c(Nombre.x, Nombre.y)) %>% mutate(Nombre= Nombre_def) %>%select(!Nombre_def)

df_fruta_pescados <- df_fruta_pescados%>% mutate(Importe_def = ifelse(is.na(Importe.x), Importe.y, Importe.x)) %>% select(!c(Importe.x, Importe.y))%>% mutate(Importe=Importe_def) %>% select(!Importe_def)

df_fruta_pescados<- df_fruta_pescados %>% mutate(OP_def = ifelse(is.na(OP.x), OP.y, OP.x)) %>% select(!c(OP.x, OP.y))%>% mutate(OP=OP_def) %>% select(!OP_def)

df_fruta_pescados <-df_fruta_pescados %>%
  mutate(Factura_simpl_def = ifelse(is.na(Factura_simpl.y), Factura_simpl.x, Factura_simpl.y)) %>%
  select(-c(Factura_simpl.y, Factura_simpl.x)) %>%
  mutate(Factura_simpl = Factura_simpl_def) %>%
  select(-Factura_simpl_def)

df_fruta_pescados <- df_fruta_pescados %>% mutate(Total_euros_def = ifelse(is.na(Total_euros.x), Total_euros.y, Total_euros.x)) %>% select(!c(Total_euros.x, Total_euros.y)) %>% mutate(Total_euros=Total_euros_def) %>% select(!Total_euros_def)

df_fruta_pescados <- df_fruta_pescados %>% mutate(Eur_el_Kg_def = ifelse(is.na(Eur_el_Kg.x), Eur_el_Kg.y, Eur_el_Kg.x)) %>% select(!c(Eur_el_Kg.x, Eur_el_Kg.y)) %>% mutate(Eur_el_Kg=Eur_el_Kg_def) %>% select(!Eur_el_Kg_def)

df_fruta_pescados <- df_fruta_pescados %>% mutate(Info_def = ifelse(is.na(Info.x), Info.y, Info.x)) %>% select(!c(Info.x, Info.y)) %>% mutate(Info=Info_def) %>% select(!Info_def)

df_fruta_pescados <- df_fruta_pescados %>% mutate(Kgs_def = ifelse(is.na(Kgs.x),Kgs.y, Kgs.x)) %>% select(!c(Kgs.x, Kgs.y)) %>% mutate(Kgs= Kgs_def) %>%select(!Kgs_def)

df_calles <- separate(df_calles, Municipio, into = c("COD_Postal", "Municipio"), sep = " ", remove = FALSE, extra = "merge")

```


Variable       | Descripción                                    
---------------|------------------------------------------------
Productos      | Nombre y cantidad del producto                 
PUnidad        | Precio por unidad del producto                 
Cantidad       | Cantidad del producto                          
Nombre         | Nombre del producto                            
Importe        | Precio del producto                            
OP             | Identificador de la operación                  
Kgs            | Peso (en kilogramos) del producto              
Eur_el_kg      | Precio del producto por kg                     
Info           | Información del producto                       
Factura_simpl  | Factura de la compra                           
Total_euros    | Importe total de la compra                     
Calle          | Calle del supermercado                         
Municipio      | Municipio donde se encuentra el supermercado   
Fecha          | Fecha de la compra                             
nombre_super   | Información del supermercado                   
Parking        | Si el cliente ha utilizado el parking o no


##1.3 Análisis de missing data en nuestro conjunto de interés:
  En este subapartado pasaremos a detectar datos o valores anómalos, ya sean NA's (valores perdidos) u outliers   (valores‘alejados’ del resto). En primer lugar, respecto a los NA's, podemos ver que solamente existen en 4     columnas. Existen NA´s en las columnas (vbles.) PUnidad y en Total_euoros cuando se hace referencia a las       frutas y veduras y a pescados.
  Esto tiene sentido, ya que, ambos dos tienen un formatodiferente al resto de productos, como ya hemos           comentado anteriormente. Además, existen NA´s en las columnas (vbles.) Kgs, Eur_el_kg y en Info cuando se hace   referencia al resto de productos que no sean ni frutas ni verduras ni pescados. Esto también tiene sentido, ya   que, complementa a lo anterior, es decir, el resto de productos no constan de ese tipo de formato. En segundo   lugar, para la detección de outliers sólo hace falta visualizar la gráfica (boxplot) dónde constan los 4        métodos vistos en la asignatura de Tratamiento de los Datos:
  
`reglasigma(x)`, `reglahampel(x)`, `reglaboxplot(x)` y`reglapercentil(x)`.

Ahora, se hará una breve introducción a cada método:

  • Regla sigma 3 (reglasigma(x)): Este método asume que los datos siguen una distribución gaussiana, es decir,     una forma de campana. Utiliza la media y la desviación estándar para caracterizar los datos. Según esta         regla, los valores que están más allá de 3 desviaciones estándar de la media se consideran outliers.
  
  • Identificador Hampel (reglahampel(x)): A diferencia de la regla sigma, este método no asume que los datos       sigan una distribución gaussiana. En su lugar, utiliza estimadores robustos como la mediana y la desviación     absoluta mediana(MADM) para caracterizar los datos. Los valores que están más allá de 3 veces la MADM se        consideran outliers.
  • Regla boxplot (reglaboxplot(x)): Este método utiliza un diagrama de caja (boxplot) para visualizar la           distribución de los datos. Define los valores típicos superiores e inferiores hasta el cuartil 75% y 25%        respectivamente, y la dispersión se calcula como el rango intercuartílico (IQR). Los valores que están más      allá de 1.5 veces el IQR por encima del cuartil 75% o por debajo del cuartil 25% se consideran outliers.
  • Percentiles (reglapercentil(x)): Este método considera que cualquier valor que esté fuera del rango del         percentil 5% y 95% se puede considerar como atípico. Es decir, los valores que están por debajo del             percentil 5% o por encima del percentil 95% se consideran outliers.
 
 

```{r include=FALSE}
madm <- function(x, na.rm=T) { 
  aux1 = median(x,na.rm = TRUE)
  aux2 = x-aux1
  aux3 = abs(aux2)
  aux4 = median(aux3,na.rm = TRUE)
  aux5 = 1.4826*aux4
  return(aux5)
}

# Regla 3 sigma:
reglasigma <- function(x) { 
  m <- mean(x,na.rm = T)
  s <- sd(x,na.rm = T)
  out <- (x>(m+3*s)|x<(m-3*s))
}


# Identificador Hampel:
reglahampel <- function(x) { 
  m <- median(x,na.rm = T)
  s <- madm(x,na.rm = T)
  out <- (x>(m+3*s)|x<(m-3*s))
}

# Regla boxplot:
reglaboxplot <- function(x) { 
  q1 <- quantile(x, 1 / 4, na.rm = T)
  q2 <- quantile(x, 3 / 4, na.rm = T)
  i <- IQR(x, na.rm = T)
  out <- (x>(q2+1.5*i)|x<(q1-1.5*i))
}

# Percentiles:
reglapercentil <- function(x){ 
  q1 <- quantile(x, 0.05, na.rm = T)
  q2 <- quantile(x, 0.95, na.rm = T)
  out <- (x>q2|x<q1)
}

```

```{r echo=FALSE}
#Creamos una lista de funciones de detección de outliers:
metodos <- list(reglasigma=reglasigma,reglahampel=reglahampel,reglaboxplot=reglaboxplot,reglapercentil=reglapercentil)

#Aplicamoslos métodos de detección de outliers a las columnas numéricas del dataframe:
df_tickets_out <- df_tickets %>% select(Total_euros) %>% mutate(across(where(is.numeric), metodos))

#Número de outliers detectados:
num_outliers <- df_tickets_out %>% select(contains("regla")) %>% summarise(across(everything(),~sum(.,na.rm = TRUE))) 


#Valores etiquetados como outliers:
sort(df_tickets_out$Total_euros[df_tickets$Total_euros_reglasigma])
sort(df_tickets_out$Total_euros[df_tickets$Total_euros_reglahampel])
sort(df_tickets_out$Total_euros[df_tickets$Total_euros_reglaboxplot])
sort(df_tickets_out$Total_euros[df_tickets$Total_euros_reglapercentil])

#Graficamos:
 df_tickets_out %>%
pivot_longer(cols = contains("regla"), names_to = "regla", values_to = "outliers")%>%
ggplot(aes(x = regla, y = Total_euros, color = outliers)) + geom_point() +
  labs(title = "Número de outliers detectados por método",
       x = "Método de detección de outliers",
       y = "Total_euros") + 
   theme(axis.text.x = element_text(angle = 45, hjust = 1))
 
ggsave("./graficas/GraficaOutliers.jpg")

```
##FIGURA 1: Gráfica de outliers

  Como se puede observar en el gráfico de la figura 1,en cada columna encontramos un método distinto para         encontrar outliers. Vemos que en el método de percentiles tenemos outliers, podemos apreciarlo por los puntos   de otro color azul. Además, nuestra gráfica está compuesta por líneas con puntos, ya que cada una de estas es   un ticket diferente, por lo que los outliers se presentan en unos tickets concretos no en todos. Si nos         fijamos bien, sólo aparecen outliers en la regla percentil ya que, este es el método más sensible, es decir     detecta los outliers con mayor precisión, como también vimos el la Práctica 5 de la asignatura.

##2. Exploración / visualización.
  Una vez hemos asegurado que nuestros datos están correctamente en el dataframe, y, observando que tienen los    valores correctamente etiquetados y están almacenados con el tipo correcto, además de conocer el origen de los   NA, podemos empezar a buscar posibles patrones entre las variables de los tickets. Tras observar nuestros       datos, nos surgen una serie depreguntas:

-¿Influye la hora de compra con el número de tickets enesos intervalos de tiempo?, y por consiguiente, ¿influye   en el precio total?

-¿Qué productos tienen la mayor variabilidad en los precios? ¿Los precios de los productos se mantienen en todos  los supermercados?

-¿Qué frutas y pescados han sido los más consumidos por los clientes? ¿Y qué productos han sido los más           vendidos?

-¿Existe diferencia en el tamaño del ticket de compra entre aquellos clientes que utilizan el servicio de         parking del supermercado y aquellos que no lo utilizan?

-¿Cuántos tickets están registrados en cada población?

  Todas estas preguntas se intentarán responder en el presente documento, mostrando las respectivas               representaciones gráficas con los tipos de datos correctos, ya que el tipo de gráfica empleada será             correspondida con un tipo de variables u otras.

##2.1. Análisis univariante:

  Distinguiremos el análisis entre las variables de tipo numérico, las de tipo categórica y las tipo factor, que   son una forma específica de representar variables categóricas. Este análisis es crucial, ya que, ciertos        estadísticos descriptivos (como por ejemplo la media) carecen de sentido en las variables categóricas.
  
##2.2. Análisis bivariante:
  
```{r echo=FALSE}  
  
 # 1. ¿Influye la hora de compra con el número de tickets en esos intervalos de tiempo?
#, y por consiguiente, ¿influye en el precio total?

#FALTA ORDENAR EN ORDEN CRECIENTE LOS INTERVALOS.
#Creamos los intervalos de tiempo:
intervalos <- seq(from = as.POSIXct("09:00", format = "%H:%M"), 
                  to = as.POSIXct("21:30", format = "%H:%M"), 
                  by = "4 hours")

#Define los límites de los intervalos
limites_intervalos <- c("09:00", "13:00", "17:00", "21:30")

#Define las etiquetas de los intervalos
etiquetas_intervalos <- c("9:00 a 12:59", "13:00 a 16:59", "17:00 a 21:30")

#Crea una función para asignar etiquetas de intervalos
asignar_intervalo <- function(Hora) {
  for (i in seq_along(limites_intervalos)) {
    #print(paste("Hora:", Hora))
    #print(paste("Límite inferior:", hm(limites_intervalos[i])))
    #print(paste("Límite superior:",hm(limites_intervalos[i+1])))
    if(hm(Hora) < hm(limites_intervalos[i]) ) {
    
      return(etiquetas_intervalos[i-1])
    }else if(hm(Hora) > hm(limites_intervalos[3])){
      return(etiquetas_intervalos[3])
    }
  }
  return(etiquetas_intervalos[length(etiquetas_intervalos)])  # Para el último intervalo
}



#Aplica la función a la columna de horas:

df_calles$intervalos <- sapply(df_calles$Hora, asignar_intervalo)

df_calles %>% group_by(intervalos) %>% summarise(contador =  n())  %>% ggplot(aes(x=intervalos, y= contador, fill = intervalos)) + geom_bar(stat = "identity") + labs(title = "Gráfica 1",
       subtitle = "Hora de compra V/S número de tickets en ese intervalo",
       x = "Intervalos horarios",
       y = "Número de Tickets",
       caption = "Los datos han sido extraídos de tickets de Mercadona")
ggsave("./graficas/Grafica1.jpg") 
  
```  

  FIGURA 2: ¿Influye la hora de compra con el número de tickets en esos intervalos de tiempo?

  Analizamos esta pregunta mediante una gráfica de barras. En primer lugar hemos creado esta gráfica con          ‘geom_bar’ debido a que se trata de variables categóricas, ya que se trata de un intervalo de tiempo y no se    puede medir directamente en términos numéricos continuos. Para crearla hemos separado los tickets según el      intervalo de horas en el que se realizó la compra. Debido a la falta de tickets de 21:00 a 21:30 la gráfica     contenía un intervalo insignificante, por lo que lo unimos con el anterior intervalo. En nuestra gráfica        podemos observar que, con diferencia, la hora en la que más se compra es por la tarde de 17:00 a 21:30, esto    puede deberse a que la gran mayoría de gente trabaja por la mañana además de que lo niños van a clase, por      ello, es más común que vayan a comprar por la tarde. Vemos también que el intervalo con menos conumo es el de   9:00 a 13:00, lo cual puede deberse al mismo motivo. 
  Además, los dos intervalos más comunes también se encuentran cerca de las comidas más abundantes del día como   son la comida y la cena.

```{r echo=FALSE}

#¿influye en el precio total?
df_calles %>% ggplot(aes(x=intervalos, y= Total_euros, fill = intervalos)) + geom_boxplot()  + 
       labs(title = "Gráfica 1.1",
       subtitle = "Relación entre la hora de compra y el precio total",
       x = "Intervalos horarios",
       y = "Total_euros",
       caption = "Los datos han sido extraídos de tickets de Mercadona")
ggsave("./graficas/Grafica1.1.jpg")
```

  FIGURA 3: ¿Influye en el precio total la hora en la que se compra?
  
  Al igual que en la figura anterior, se trata de variables categóricas por lo que para responder a esta          pregunta utilizamos un boxplot. Para crear esta gráfica, analizamos el precio total respecto de la hora de      compra de ese ticket. Podemos observar que el precio más elevado es a primera hora (bigotes diagrama de         cajas), es decir, la hora en la que menos gente acude y el más bajo es a medio día. Por lo que observamos que   la gente gasta más dinero cuando compra por la mañana y esto puede deberse a que compran para todo el día y al   comprar por la tarde compran para ese momento. Además, podemos ver que cada intervalo tiene asociada una        mediana: el primer intervalo de compra tiene una mediana de unos 65€ aproximadamente, el segundo intervalo de   compra tiene una mediana sobre unos 35€ y, el último, tiene una mediana de 50€. Por último, destacar que el     intervalo de 17:00 a 21:30 tiene una mayor variabilidad en el precio total de cada ticket.

```{r echo=FALSE}
# 2. ¿Qué productos tienen la mayor variabilidad en los precios? Está relacionado el alto precio de un ticket con un alto consumo de frutas y verduras?¿Y de otro tipo de productos?

# ¿Qué productos tienen la mayor variabilidad en los precios?

# Filtramos los datos para solo considerar precio/unidad
df_unidad <- df_productos_todos %>%
  filter(Cantidad == 1)  

# Agrupamos
variabilidad_precios <- df_unidad %>%
  group_by(Nombre) %>%
  summarise(desviacion_estandar = sd(Importe)) %>%
  arrange(desc(desviacion_estandar)) %>%
  slice(1:6)

# Gráfico top productos con más variación
ggplot(variabilidad_precios, aes(x = Nombre, y = desviacion_estandar, fill = Nombre)) +
  geom_bar(stat = "identity") +
  labs(title = "Gráfica 2.1",
       subtitle = "Productos con mayor variabilidad de precios",
       x = "Productos",
       y = "Desviación estándar de precios",
       caption = "Los datos han sido extraídos de tickets de Mercadona") +
  theme(axis.text.x = element_blank())

ggsave("./graficas/Grafica2.1.jpg")


```
  FIGURA 4: ¿Qué productos tienen la mayor variabilidad en los precios?

  Para poder responder correctamente a esta pregunta, realizamos un gráfico de barras, debido a que las           variables son de tipo categórico, ya que representan diferentes nombres de productos. Las variables             categóricas son aquellas que toman valores de una categoría o grupo específico, en lugar de valores numéricos   continuos. En este caso, los nombres de los productos (como “arroz basmati”, “cebolla roja”, etc.) son          categorías distintas, y la gráfica muestra cómo varía la desviación estándar de precios para cada uno de estos   productos. En esta gráfica mostramos los 6 productos en los que su precio es el más variable. El papel          higiénico se encuentra entre éstos debido a que este está compuesto por celulosa, un componente que antes era   de gran escasez, pero ahora se está haciendo más abundante, por lo que el precio de este está bajando. Por      otro lado, también observamos que el fresón es otro de los elementos cuyo precio varía en abundancia, debido a   que esta fruta es mucho más cara cuando no está en temporada, pero su precio disminuye en temporada. Por        último, destacamos también el arroz. Últimamente su precio se ha visto incrementado debido a que la India, el   mayor exportador de arroz a España ha decidido prohibir la venta de arroz al extranjero, por lo que debido a    esta escasez, su precio ha aumentado.


```{r echo=FALSE}
# 3. ¿Qué frutas y pescados han sido los más consumidos por los clientes? 
      # ¿y qué productos han sido los más vendidos?

#Los 5 frutas/verduras y pescados más vendidos son::

df_fruta_pescados %>% group_by(Nombre) %>% summarise(contador =  n())  %>% 
                arrange(desc(contador)) %>%   slice(1:5) %>%
               ggplot(aes(x=Nombre, y= contador, fill = Nombre)) + geom_bar(stat = "identity") + 
       labs(title = "Gráfica 3",
       subtitle = "Relación entre frutas y pescados, y su consumo",
       x = "Frutas y pescados",
       y = "Frecuencia",
       caption = "Los datos han sido extraídos de tickets de Mercadona")+
      theme(axis.text.x = element_blank())

ggsave("./graficas/Grafica3.jpg")
#Los 3 productos más vendidos son:

df_productos_todos %>% group_by(Nombre) %>% summarise(contador =  n())  %>% 
                arrange(desc(contador)) %>%   slice(1:8) %>%
               ggplot(aes(x=Nombre, y= contador, fill = Nombre)) + geom_bar(stat = "identity")  + 
       labs(title = "Gráfica 3.1",
       subtitle = "Relación entre productos y su consumo",
       x = "Productos",
       y = "Frecuencia",
       caption = "Los datos han sido extraídos de tickets de Mercadona") + 
       theme(axis.text.x = element_blank())





########################################
#Quitar bolsa plástico , y hacer gráfica con media total_euros y ver bolsas.

ggsave("./graficas/Grafica3.1.jpg")
```

  FIGURA 6: ¿Qué frutas y pescados han sido los más consumidospor los clientes?

  Para responder correctamente a esta pregunta, creamos un gráfico de barras. Utilizamos un gráfico de barras     porque las variables que estamos analizando son categóricas, es decir,representan diferentes nombres de         productos. En lugar de valores numéricos continuos, como precios exactos, estamos interesados en cómo varía la   desviación estándar de cada uno de estos productos. Por lo tanto, la gráfica nos muestra visualmente esa        variabilidad. En concreto, en esta gráfica aparecen las frutas y verduras más compradas por los consumidores.   Vemos que aparecen tanto el plátano como la banana y esto es debido a que es una fruta cuyo precio es muy       asequible en el mercado, además, destacar que el plátano se consume más porque la fuente de dónde proviene es   Canarias y, es requerido para múltiples recetas. Otra fruta muy consumida es la manzana. Esto se debe a que     son muy baratas, versátiles culinariamente y prácticas para consumir a lo largo del día.

  FIGURA 7: ¿Qué productos han sido los más vendidos?

  Las variables categóricas son aquellas que representan diferentes categorías o grupos específicos, en lugar de   valores numéricos continuos. En el contexto de la gráfica que estamos analizando, las variables son             categóricas porque se refieren a nombres de productos. Interpretando la gráfica, podemos ver que en función de   los tickets obtenidos, el producto más vendido es la panceta. Esto puede deberse a su gran versatilidad con     distintos productos, ya que puede combinarse con gran cantidad de productos. Los demás se consumen más o menos   con la misma frecuencia. En cuanto al jamón podemos deducir la misma conclusión que la panceta además de ser    un plato típico que se basta de sí mismo para disgustarse. Por otro lado encontramos el queso. Un lácteo muy    común en la mayoría de las neveras de nuestros hogares debido, de nuevo, a su fácil combinación con otros       elementos. También encontramos productos como la soja con chocolate, las pipas o los crackers de espelta que    son consumidos normalmente como snack hacen que cualquier consumidor quiera tener uno de estos productos en su   despensa para consumirlos en cualquier momento.
  
  
  
```{r echo=FALSE}
# 4. ¿Existe diferencia en el tamaño del ticket de compra entre aquellos clientes
     #que utilizan el servicio de parking del supermercado y aquellos que no lo utilizan?


 df_calles  %>% group_by(Parking) %>% summarise(contador =  n())  %>% 
                arrange(desc(contador)) %>% ggplot(aes(x=Parking, y= contador, fill = Parking))  + geom_bar(stat = "identity") +
       labs(title = "Gráfica 4",
       subtitle = "Relación entre la cantidad de productos y el servicio Parking",
       x = "Parking",
       y = "Cantidad Productos",
       caption = "Los datos han sido extraídos de tickets de Mercadona")
ggsave("./graficas/Grafica4.jpg")
       
```  
  FIGURA 8: ¿Existe diferencia en el tamaño del ticket de compra entre aquellos clientes que utilizan el                      servicio de parking del supermercado y aquellos que no lo utilizan?
  Como podemos observar, nos encontramos frente a otro gráfico de barras, representado con un bar_plot y          responde a nuestra pregunta con un rotundo no. Esto se explica gracias a que el tamaño de la compra no está     relacionado con si el cliente ha cogido parking o no, ya que se pueden dar factores como que haya aparcado su   vehículo relativamente cerca del supermercado, viva cerca del supermercado, etc.
  
```{r echo=FALSE}  
  # ¿Existe diferencia entre el precio total de un ticket y el uso del servicio Parking?
       
        df_calles %>% group_by(Parking) %>% ggplot(aes(x=Parking, y= Total_euros, fill = Parking))  + geom_boxplot() + labs(title = "Gráfica 4.1 "   , subtitle = "Relación entre Total_euros y el servicio Parking",
       x = "Parking",
       y = "Total_euros",
       caption = "Los datos han sido extraídos de tickets de Mercadona")
ggsave("./graficas/Grafica4.1.jpg")
``` 
  
  FIGURA 9: ¿Existe diferencia entre el precio total de un ticket y el uso del servicio Parking?
  En este diagrama en caja, realizado con la función boxplot() (cargado en el paquete base de R), podemos         observar como claramente el servicio parking está relacionado con el total en euros del ticket. Esto se puede   dar gracias a que el cliente puede hacer una compra elevada en cuanto a productos por la facilidad de tener     parking pero dado que en la gráfica de antes hemos visto que no necesariamente debe estar relacionado el        tamaño del ticket con el uso del servicio parking podemos deducir que el parking también tiene un coste y como   consecuencia ese coste se añade al ticket por lo que acabaría influyendo en el total de euros del coste. En     cuanto al diagrama en caja en sí, podemos decir que cada caja representa la distribución de los gastos totales   para cada grupo (Sí y No). La línea central de cada caja indica la mediana de los gastos, destacar que ambas    cajas tienen la mimsa mediana (50€). El rango intercuartílico (la altura de la caja)muestra la variabilidad y   dispersión de los datos alrededor de la mediana. Las líneas que se extienden desdela caja (bigotes) indican la   variabilidad fuera del cuartil superior e inferior, pero dentro de un rango típico de datos.
  
```{r echo=FALSE}
# 5. ¿Cuántos tickets están registrados en cada población?
 df_calles %>% group_by(Municipio)  %>% summarise(contador =  n(), avg = mean(Total_euros)) %>% ggplot(aes(x=Municipio, y= contador, fill = Municipio)) +     geom_bar(stat="identity") +
       labs(title = "Gráfica 5",
       subtitle = "Relación entre la población y el número de tickets",
        x = "Población",
        y = "Cantidad de tickets",
        caption = "Los datos han sido extraídos de tickets de Mercadona") +
        theme(axis.text.x = element_blank())

ggsave("./graficas/Grafica5.jpg")

  
```  
  FIGURA 10: ¿Cuántos tickets están registrados en cada población?

  En este diagrama de barras nos topamos con una gráfica realizada mediante la función geom_bar() ya que como     hemos mencionado antes utilizamos este tipo de gráficos siempre y cuando se trate de variables categóricas.     Interpretando el diagrama vemos que existe un número mayor de tickets en madrid por ejemplo, o valencia. Esto   se puede deber a que son ciudades más grandes y con una población bastante más elevada respecto al resto de     ubicaciones. También podríamos tener en cuenta que estas dos ciudades son dos de las ciudades con más           estudiantes del país, lo que conlleva a una mayor compra en supermercado y obviamente, la obtención de ticket.   Sabiendo esto, podemos deducir que los pueblos/ciudades más pequeños/pequeñas serán los que menos número de     tickets tengan.
 
  
##Gráfica Correlación:
```{r echo=FALSE}

df_productos_todos %>% group_by(Factura_simpl, Total_euros) %>% summarise(contador = n()) %>% ggplot(aes(x = contador, y = Total_euros)) +
  geom_point() +
  geom_smooth(method = "lm", se = FALSE) + # Añadir línea de regresión
  labs(title = "Correlación entre Cantidad y Total Euros", 
       x = "Cantidad", y = "Total Euros") 
ggsave("./graficas/GraficaCorrelacion.jpg")
```  
  FIGURA 11: La gráfica muestra un diagrama de dispersión con una línea de tendencia o recta de regresión,        analizando la relación entre la cantidad de productos comprados y el total gastado en euros. Cada punto         representa una observación individual que muestra la cantidad de productos comprados y el total gastado         asociado a esa cantidad. La recta muestra la correlación entre las dos variables, sugiriendo una tendencia      positiva donde a medida que aumenta la cantidad de productos, el total gastado en euros también aumenta. En     cuanto a los puntos más ‘alejados’, podemos decir que se trata de outliers, es decir, valores atípicos o        aberrantes. Estos pueden ser los clientes cuyo comportamiento   de compra no se ciñe a la tendencia general,    es decir, a la distribución del resto de clientes (recta). 
  
  
  
##3. CONCLUSIÓN:
  En este momento del proyecto, haremos una breve conclusión para poder clarificar el objetivo de este trabajo.   Una vez hemos respondido las preguntas planteadas sobre nuestro dataframe objetivo (df_tickets), ya sea el      cómo se distribuye una variable numérica (Total_euros), una categórica (Productos) o una tipo factor(Parking),   buscar diferentes relaciones entre nuestro entorno de variables, identificando por su tipo (numérico-numérico,   categórico-numérico, categórico-categórico) es la etapa más importante de un correcto análisis. Más aún es el   haber podido acceder a diversos métodos destacables y potentes como los métodos de detección de outlayers.      Todo esto nos ha aportado un dominio del conocimiento de la distribución de cada ticket de nuestro dataframe    sin necesidad de ser expertos en esta área de estudio. Además, en el transcurso del proyecto se ha aprendido a   cómo aplicar el temario de la asignatura de Tratamiento de los Datos sobre un problema real en Ciencia de       Datos. Por otro lado, también hemos aprendido a tomar decisiones a la hora de interpretar un gráfico, tanto de   manera individual como de forma conjunta, dotándonos así de competencias requeridas en nuestros trabajos del    futuro.  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
  
