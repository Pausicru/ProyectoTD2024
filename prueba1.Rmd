---
title: "ProyectoTD2024"
output: html_document
date: "2024-03-26"
authors: "Marta Molina, Iñaki Martín, Nerea Galera, Sergio Mut"
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
rm(list=ls())
```

##Intruducción al trabajo:
Este proyecto trata sobre desarrollar un programa que permita analizar una serie de tickets de compra de supermercado.

El objetivo es enfrentarse a un problema real de tratamiento de datos, realizando un seguimiento de (evolución de precios, compras más habituales, productos más consumidos, supermercado habitual, hora de compra, etc).

Este proyecto ha sido realizado con control de cambios GIT. Tiene un repositorio compartido entre las miembros del grupo llamado ProyectoTD2024 en la plataforma GitHub y en el cual se ven los cambios y desarrollo del trabajo.

##Información del proyecto:
Se dispone de varios tickets para empezar a trabajar y un jupiter notebook de python (TicketPDF2TXT.ipynb) que transforma todos los ficheros con extensión pdf presentes en la carpeta data en ficheros de texto con toda la información.

##Instalación de paquetes:
```{r}
#Este bloque se encarga de instalar los paquetes necesarios.

packages = c("tidyverse","knitr","reshape2")
package.check <- lapply(packages, FUN = function(x) {
  if (!require(x, character.only = TRUE)) {
    install.packages(x, dependencies = TRUE,repos='http://cran.rediris.es')
  }
  library(x, character.only = TRUE)
})

search()
```
##Importación de datos y creación del DataFrame:
```{r}
#Cargamos en la vble. 'rutas' los archivos que deseamos leeer,
#constamos de 12 archivos a leer, que corresponden
#a 12 tickets de compra de supermercado:
rutas <- list.files("data/",  pattern = "\\.txt$")
```

```{r}
#DATAGRAMES individuales:

#Data frame para almacenar todos los datos de los tickets.
df_todos <- data.frame()  
#Data frame para almacenar los datos de los productos de los tickets.
df_productos_todos <- data.frame() 
#Data frame para almacenar los datos de la fruta de los tickets.
df_fruta_todos <- data.frame()
#Data frame para almacenar los datos del pescado de los tickets.
df_pescado_todos <- data.frame()  

#Recorremos los archivos mediante un bucle 'para',
#para así poder cargar en un data frame todos
#los datos de los tickets:
for (archivo in rutas){
  
  #Utilizamos la función 'readlines()'
  x <- readLines(paste("data", archivo, sep = "/"), encoding = "latin1")
   
  prod <- x[8:length(x)]   #Notamos que las primeras líneas de los tickets son iguales siempre:
  producto <- list()  #Lista para almacenar los productos.
  lista_pescado = list()  #Lista para almacenar los productos de pescado.
  lista_fruta = list()  #Lista para almacenar los productos de fruta.
  final <- list()  #Lista para almacenar la información final de cada ticket.
  enc = FALSE  #Variable para controlar si se ha encontrado la línea 'TOTAL (€)'.
  pescado = FALSE  #Variable para controlar si se está procesando pescado.
  fruta = FALSE  #Variable para controlar si se está procesando fruta.
  parking = FALSE  #Variable para controlar si se ha encontrado la línea 'PARKING'.
  
  #Bucle 'para' con el objetivo de encontrar los elementos deseados:
   for (elemento in prod){
     
     #Vemos que, el final de cada tiquet es diferente,
     #depende de los productos de cada ticket.
     #Destacar a partir de la línea donde se encuentra
     #'TOTAL (€)' :

     if (grepl("TOTAL", elemento)){
         enc = TRUE
     }
     if (grepl("PARKING", elemento)){
         parking = TRUE
     }
      #Comprobar si la línea no termina con un número 
      #y no se ha empezado a procesar pescado.
      if (!grepl("\\d$", elemento) & pescado == FALSE) {
         fruta = TRUE # Indicar que se está procesando fruta
     }

    #Procesamiento de la línea dependiendo de las condiciones anteriores.
     if (enc == FALSE & pescado == FALSE & fruta == FALSE & parking == FALSE){
         producto <- c(producto, elemento)  # Añadir elemento a la lista de productos
     }
     if (fruta == TRUE & enc == FALSE & pescado == FALSE & parking == FALSE){
       lista_fruta <- c(lista_fruta, elemento) #Añadir elemento a la lista de productos de fruta.
     }
     if (pescado == TRUE & enc == FALSE & fruta == FALSE){
       lista_pescado <- c(lista_pescado, elemento) #Añadir elemento a la lista de productos de pescado.
     }
     if (enc == TRUE){
       final <- c(final, elemento) #Añadir elemento a la lista de información final.
     }
          if (grepl("PESCADO", elemento)){
         pescado = TRUE #Indicar que se está procesando pescado.
         fruta = FALSE #Resetear la variable de procesamiento de fruta.
     }
     
   }
   partes <- strsplit(x[5], " OP: ")[[1]]
   id <- strsplit(x[6], "FACTURA SIMPLIFICADA: ")[[1]]
   telef <- strsplit(x[4], "TELÉFONO: ")[[1]]
   # Crear el dataframe principal con la información obtenida
   df <- data.frame(Nombre = x[1], Calle = x[2], Municipio = x[3], Telefono = telef[2], Fecha = partes[1],  OP = partes[2], Factura_simpl= id[[2]] , Productos = producto[0:length(producto)])
  
  #Convertir el dataframe de formato ancho a formato largo:
  df <- pivot_longer(df, names_to = "Producto", values_to = "Productos", cols = -c("Nombre","Calle", "Municipio", "Telefono", "Fecha", "OP", "Factura_simpl")) 

  #Agregar el dataframe actual al dataframe general:
  df_todos <- rbind(df_todos, df)
  total_columnas <- ncol(df)
  posicion <- total_columnas - 1
  df <- df[, -posicion]
  
  #Cantidad:
  df_productos <- select(df, 1,7, 8) #tenemos en cuenta el identificador ('Factura_simpl').
  df_separado <- df_productos %>%
  mutate(Cantidad = substr(Productos, 1, 1))
  df_separado$Productos <- substr(df$Productos, 2, nchar(df$Productos))
  df_separado$Cantidad <- as.numeric(df_separado$Cantidad)
  
  #Importe:
  df_separado$Importe <- sub("^.*\\s+(\\d+[,.]\\d+)$", "\\1", df_separado$Productos)
  df_separado$Importe <- gsub(",", ".", df_separado$Importe)
  df_separado$Importe <- as.numeric(df_separado$Importe)
  
  #Precio por Unidad:
  df_separado <- df_separado %>% mutate(PUnidad = Importe / Cantidad)

  #Nombre del producto:
  df_separado$Nombre <- substr(df_separado$Productos, 
                             1, 
                             nchar(df_separado$Productos) - nchar(format(df_separado$Importe, nsmall = 2)) - 1)
  df_separado$Nombre[df_separado$Cantidad > 1] <- substr(df_separado$Nombre[df_separado$Cantidad > 1], 
                                                        1, 
                                                        nchar(df_separado$Nombre[df_separado$Cantidad > 1]) - nchar(format(df_separado$PUnidad, nsmall = 2)) - 1)

#Sobrescribir la columna Productos con sólo el nombre del producto:
  df_separado$Productos <- df_separado$Nombre
  
  
  df_separado$Total_euros <- sub("^.*\\s+(\\d+[,.]\\d+)$", "\\1", final[1])
  df_separado$Total_euros <- gsub(",", ".", df_separado$Total_euros)
  df_separado$Total_euros <- as.numeric(df_separado$Total_euros)
  df_separado$OP <- partes[2]
  
  #Lo añadimos en el data frame conjunto:
  df_productos_todos <- rbind(df_productos_todos, df_separado)

  
  if (fruta == TRUE & length(lista_fruta) != 0 ){
    df_fruta <- data.frame(Productos = character(), Info = character(), OP = character())
    indice <- length(lista_fruta) -1
    i <- 1  #Inicializar el índice.
  
  #Bucle 'mientras' para creación de df_fruta:
  while (i <= indice) {

    df_fruta <- rbind(df_fruta, data.frame(Productos = lista_fruta[[i]], Info = lista_fruta[[i+1]], OP = partes[[2]]))
    i <- i + 2  
  }
    df_fruta <- df_fruta %>%
    mutate(Cantidad = substr(Productos, 1, 1))
    df_fruta$Nombre <- substr(df_fruta$Productos, 2, nchar(df_fruta$Productos))
    df_fruta$Importe <- sub("^.*\\s+(\\d+[,.]\\d+)$", "\\1", df_fruta$Info)
    df_fruta$Kgs <- sub("^(\\d+[,.]\\d+).*", "\\1", df_fruta$Info)
    df_fruta$Importe <- gsub(",", ".", df_fruta$Importe)
    df_fruta$Kgs <- gsub(",", ".", df_fruta$Kgs)
    df_fruta$Importe <- as.numeric(df_fruta$Importe)
    df_fruta$Kgs <- as.numeric(df_fruta$Kgs)
    df_fruta$Factura_simpl <- id[[2]]
    df_fruta <- df_fruta %>% mutate(Eur_el_Kg = round(Importe / Kgs, 2))
    df_fruta_todos <- rbind(df_fruta_todos, df_fruta)
   
  }
  if (pescado == TRUE){
    df_pescado <- data.frame(Productos = character(), Info = character(), OP = character())
    indice <- length(lista_pescado) -1
    i <- 1  # Inicializar el índice
  
  #Bucle 'mientras' para creación de df_pescado:
  while (i <= indice) {
    df_pescado <- rbind(df_pescado, data.frame(Productos = lista_pescado[[i]], Info = lista_pescado[[i+1]], OP = partes[2]) )
    i <- i + 2  
  }

    df_pescado$Nombre <- substr(df_pescado$Productos, 1, nchar(df_pescado$Productos))
    df_pescado$Importe <- sub("^.*\\s+(\\d+[,.]\\d+)$", "\\1", df_pescado$Info)
    df_pescado$Kgs <- sub("^(\\d+[,.]\\d+).*", "\\1", df_pescado$Info)
    df_pescado$Importe <- gsub(",", ".", df_pescado$Importe)
    df_pescado$Kgs <- gsub(",", ".", df_pescado$Kgs)
    df_pescado$Importe <- as.numeric(df_pescado$Importe)
    df_pescado$Kgs <- as.numeric(df_pescado$Kgs)
    df_pescado <- df_pescado %>% mutate(Eur_el_Kg = round(Importe / Kgs, 2))
    df_pescado$Factura_simpl <- id[[2]]
    df_pescado_todos <- rbind(df_pescado_todos, df_pescado)

  }
}
```

```{r}
#En este momento de la Importación, realizaremos un DATAFRAME conjunto(df_tickets).


#Tenemos en cuenta el identificador de cada ticket, y además destacar
#cada tipo de formado dentro de productos:fruta, pescado y productos restantes.
#Fruta:
x_fruta <- df_fruta_todos$Productos 
#Productos en general(sin fruta ni pescado), ya que tienen un formato != :
x_prod <- df_productos_todos$Productos
#Pescados:
x_pescado <- df_pescado_todos$Productos
#Añadimos al vector de fruas, el vector de productos restantes,
#mediante un append:
Productos <- append(x_fruta, x_prod)

#Dataframe uniendo la fruta y los productos restantes,
#mediante un full_join:
df_total <- full_join(df_fruta_todos, df_productos_todos, by="Productos")

#Arreglamos el dataframe con el fotmato adecuado para las vbles correspondientes:
df_total <- df_total %>% mutate(Nombre_def = ifelse(is.na(Nombre.x), Nombre.y, Nombre.x)) %>% select(!c(Nombre.x, Nombre.y)) %>% mutate(Nombre= Nombre_def) %>%select(!Nombre_def)

df_total <- df_total %>% mutate(Cantidad_def = ifelse(is.na(Cantidad.x), Cantidad.y, Cantidad.x)) %>% select(!c(Cantidad.x, Cantidad.y)) %>% mutate(Cantidad=Cantidad_def) %>% select(!Cantidad_def)

df_total <- df_total %>% mutate(Importe_def = ifelse(is.na(Importe.x), Importe.y, Importe.x)) %>% select(!c(Importe.x, Importe.y))%>% mutate(Importe=Importe_def) %>% select(!Importe_def)

df_total <- df_total %>% mutate(OP_def = ifelse(is.na(OP.x), OP.y, OP.x)) %>% select(!c(OP.x, OP.y))%>% mutate(OP=OP_def) %>% select(!OP_def)

df_total <- df_total %>%
  mutate(Factura_simpl_def = ifelse(is.na(Factura_simpl.y), Factura_simpl.x, Factura_simpl.y)) %>%
  select(-c(Factura_simpl.y, Factura_simpl.x)) %>%
  mutate(Factura_simpl = Factura_simpl_def) %>%
  select(-Factura_simpl_def)


#Dataframe uniendo el df_total (fruta+productos) y los pescados,
#mediante un full_join:
df_total_def <- full_join(df_total, df_pescado_todos, by="Productos")

#Arreglamos el dataframe con el fotmato adecuado para las vbles correspondientes:
df_total_def <- df_total_def %>% mutate(Nombre_def = ifelse(is.na(Nombre.x), Nombre.y, Nombre.x)) %>% select(!c(Nombre.x, Nombre.y)) %>% mutate(Nombre= Nombre_def) %>%select(!Nombre_def)

df_total_def <- df_total_def %>% mutate(Importe_def = ifelse(is.na(Importe.x), Importe.y, Importe.x)) %>% select(!c(Importe.x, Importe.y))%>% mutate(Importe=Importe_def) %>% select(!Importe_def)

df_total_def <- df_total_def %>% mutate(OP_def = ifelse(is.na(OP.x), OP.y, OP.x)) %>% select(!c(OP.x, OP.y))%>% mutate(OP=OP_def) %>% select(!OP_def)

df_total_def <- df_total_def %>% mutate(Kgs_def = ifelse(is.na(Kgs.x),Kgs.y, Kgs.x)) %>% select(!c(Kgs.x, Kgs.y)) %>% mutate(Kgs= Kgs_def) %>%select(!Kgs_def)

df_total_def <- df_total_def %>% mutate(Eur_el_Kg_def = ifelse(is.na(Eur_el_Kg.x), Eur_el_Kg.y, Eur_el_Kg.x)) %>% select(!c(Eur_el_Kg.x, Eur_el_Kg.y)) %>% mutate(Eur_el_Kg=Eur_el_Kg_def) %>% select(!Eur_el_Kg_def)

df_total_def <- df_total_def %>% mutate(Info_def = ifelse(is.na(Info.x), Info.y, Info.x)) %>% select(!c(Info.x, Info.y)) %>% mutate(Info=Info_def) %>% select(!Info_def)

df_total_def <- df_total_def %>%
  mutate(Factura_simpl_def = ifelse(is.na(Factura_simpl.y), Factura_simpl.x, Factura_simpl.y)) %>%
  select(-c(Factura_simpl.y, Factura_simpl.x)) %>%
  mutate(Factura_simpl = Factura_simpl_def) %>%
  select(-Factura_simpl_def)

#Hacemos el entorno amigable:
df_calles <- df_todos  %>% select(!c(Producto,Productos,OP)) %>% mutate(nombre_super = Nombre)  %>% select(!Nombre) 

df_calles <- unique(df_calles)
df_calles$Fecha <- as.POSIXct(df_calles$Fecha, format = "%d/%m/%Y %H:%M") #Tener en cuenta el formato 'Fecha' correcto.

#DATAFRAME OBJETIVO (final), con la información de todos los productos de 
#cada ticket, incluidos la fruta y los pescados,
#además de la información de cada supermercado:
df_ticktes <- left_join(df_total_def,df_calles,by = "Factura_simpl")

```
## 4.Análisis Inicial de los datos.

Para una primera aproximación a los datos estudiaremos el significado de las variables para una mejor comprensión de los estadísticos y detectar datos anómalos o outliers. 

Utilizaremos el dataframe objetivo para ello, es decir, el 'df_tickets'. 

## 5.Datos anómalos.

En este subapartado pasaremos a detectar datos anómalos, ya sean NA's u outliers.


En primer lugar, respecto a los NA's, podemos ver que solamente existen en 4 columnas.

Existen NA´s en las columnas (vbles.) PUnidad y en Total_euoros cuando se hace referencia
a las Frutas y a los Pescados. 
Esto tiene sentido, ya que, ambos dos tienen un formato diferente al resto de productos.

Además, existen NA´s en las columnas (vbles.) Kgs, Eur_el_kg y en Info 
cuando se hace referencia al resto de pructos que no sean ni frutas ni pescados.
Esto también tiene sentido, ya que, complementa a lo anterior, es decir, 
el resto de productos no constan de ese tipo de formato.
a las Frutas y a los Pescados. 


En segundo lugar, para la detección de outliers sólo hace falta visualizar
las gráficas, de esta manera podremos concluir que sí hay o no presencia de
outliers en los datos.
En nuestro caso, no constan.

## 5.1.Detección de NA's:

Primero haremos un recuento de NA's del dataframe objetivo con la función 
`is.na()` , dado que son valores lógicos sumaremos la cantidad total. 
En el caso de que haya presencia de NA's utilizaremos la función `apply()` 
para contar NA´s a lo largo de filas o columnas.

```{r}

```
## 5.2.Detección de Outliers:
Un outlier es una observación (o conjunto de observaciones) que divergen
del patrón de comportamiento del resto de datos, es decir, presentan una
desviación respecto de la distribución de los datos. 
Para su detección contamos con 4 métodos: `reglasigma(x)`, `reglahampel(x)`,
`reglaboxplot(x)` y `reglapercentil(x)`.
Visualmente se pueden detectar mediante un `boxplot()`.

## 6.Preguntas planteadas con sus respectivas Visualizaciones.
```{r}
# 1. ¿Influye la hora de compra con la cantidad de productos comprados?, y por consiguiente, ¿influye en el precio total?


# 2. Está relacionado el alto precio de un ticket con un alto consumo de frutas y verduras?¿Y de otro tipo de productos?


# 3.¿Existe algún producto que siempre o casi siempre se consuma?


# 4.¿Los precios de los productos se mantienen en todos los supermercados?


# 5. ¿Cuáles son los productos que se suelen comprar juntos?


# 6. ¿Cómo varía la composición del carrito de compras según el día de la semana?


# 7. ¿Qué productos tienen la mayor variabilidad en los precios?


# 8. ¿Qué categorías de productos contribuyen más al gasto total?


# 9. ¿Qué porcentaje del gasto total se destina a productos frescos en comparación con productos envasados o procesados?


#10. ¿Existe diferencia en el tamaño del ticket de compra entre aquellos clientes que utilizan el servicio de parking del supermercado y aquellos que no lo utilizan?
```


